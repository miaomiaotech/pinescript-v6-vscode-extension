//@version=6
// 核心语法示例 - 只包含解析器和验证器能完全理解的语法

// ============================================================================
// 1. 变量声明和赋值
// ============================================================================

// 简单声明
a = 100
b = 200

// var/varip/const 声明
var counter = 0
varip sum = 0
const MAX = 500

// 类型注解
var float balance = 1000.0
varip int count = 0

// 重新赋值 (使用 :=)
counter := counter + 1
sum := sum + a

// 复合赋值
balance += 10.5
count -= 1
counter *= 2
sum /= 2
count %= 3

// ============================================================================
// 2. 解构赋值
// ============================================================================

getTuple() =>
    [100, 200]

// 解构赋值（只能用 =，不能用 :=）
[h, l] = getTuple()

// 使用解构的值
result = h + l

// ============================================================================
// 3. 函数定义
// ============================================================================

// 简单函数
double(x) => x * 2

// 带类型参数
add(float x, int y) => x + y

// 多行函数体（4个空格缩进表示代码块）
calculate(x) =>
    y = x * 2
    z = y + 10
    z

// 使用函数
value1 = double(5)
value2 = add(10.5, 20)
value3 = calculate(15)

// ============================================================================
// 4. 控制流
// ============================================================================

// if 语句（4个空格缩进）
if a > 50
    counter := counter + 1

// if-else
if b > 150
    result := 1
else
    result := 0

// for 循环
for i = 0 to 10
    sum := sum + i

// for-in 循环
numbers = [1, 2, 3, 4, 5]
for num in numbers
    sum := sum + num

// ============================================================================
// 5. 函数调用
// ============================================================================

// 简单调用
simpleFunc() => 42
returnValue = simpleFunc()

// 位置参数
myFunc(x, y) => x + y
result2 = myFunc(10, 20)

// 命名参数
namedFunc(a, b=10, c=20) => a + b + c
result3 = namedFunc(5, b=15, c=25)

// 混合位置和命名参数
result4 = namedFunc(7, c=30)

// ============================================================================
// 6. 多行函数调用（缩进不是4的倍数表示行延续）
// ============================================================================

// 2个空格缩进
multiFunc(a, b, c, d) => a + b + c + d
result5 = multiFunc(
  10,
  20,
  30,
  40
  )

// 1个空格缩进
result6 = multiFunc(
 1,
 2,
 3,
 4
 )

// 3个空格缩进
result7 = multiFunc(
   5,
   10,
   15,
   20
   )

// 缩进可以变化（只要都不是4的倍数）
result8 = multiFunc(
  1,
     2,
 3,
   4
  )

// 嵌套多行调用
nested(x) =>
    inner(y) => y * 2
    inner(x)

result9 = nested(
  multiFunc(
 10,
     20,
  30
   )
 )

// ============================================================================
// 7. 表达式
// ============================================================================

// 二元表达式
expr1 = 2 + 3 * 4
expr2 = a > b

// 一元表达式
expr3 = -10
expr4 = not expr2

// 三元表达式
expr5 = a > b ? a : b

// 逻辑表达式
expr6 = a > 50 and b < 300
expr7 = a > 50 or b < 100

// ============================================================================
// 8. 数组字面量
// ============================================================================

// 数组字面量
arr = [10, 20, 30, 40, 50]
arr2 = [1.5, 2.5, 3.5]
arr3 = [true, false, true]

// ============================================================================
// 9. 字面量
// ============================================================================

// 数字
intVal = 42
floatVal = 3.14
sciVal = 1.5e10

// 字符串
str1 = 'Hello'
str2 = "World"

// 布尔
bool1 = true
bool2 = false

// na
noValue = na

// 数组
nums = [1, 2, 3, 4, 5]

// ============================================================================
// 10. 完整示例
// ============================================================================

// 初始化
var float average = 0.0
var int total = 0

// 函数
calculateAverage(values) =>
    localSum = 0
    localCount = 0
    for val in values
        localSum := localSum + val
        localCount := localCount + 1
    localSum / localCount

// 使用
dataset = [10, 20, 30, 40, 50]
average := calculateAverage(dataset)
total := total + 1

// 条件处理
var status = "Unknown"
if average > 25
    status := "High"
else
    status := "Low"
